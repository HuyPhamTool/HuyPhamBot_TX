import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Updater, 
    CommandHandler, 
    CallbackQueryHandler, 
    CallbackContext, 
    MessageHandler, 
    filters
)
import hashlib
from datetime import datetime, timedelta
import sqlite3
import secrets
import json
from typing import Dict, Any, Optional

# --------------------- C·∫•u h√¨nh n√¢ng cao ---------------------
class Config:
    # C·∫•u h√¨nh logging chi ti·∫øt
    LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    LOG_FILE = 'taixiu_bot.log'
    LOG_LEVEL = logging.INFO
    
    # C·∫•u h√¨nh database
    DB_FILE = 'taixiu_bot.db'
    
    # C·∫•u h√¨nh admin
    ADMIN_IDS = [123456789]  # Thay b·∫±ng ID admin c·ªßa b·∫°n
    
    # Thu·∫≠t to√°n ph√¢n t√≠ch MD5
    ALGORITHMS = {
        'simple': 'Ph∆∞∆°ng ph√°p ƒë∆°n gi·∫£n (k√Ω t·ª± cu·ªëi)',
        'advanced': 'Ph∆∞∆°ng ph√°p n√¢ng cao (ph√¢n t√≠ch t·ªïng h·ª£p)',
        'statistical': 'Ph∆∞∆°ng ph√°p th·ªëng k√™ (xu h∆∞·ªõng)',
        'hybrid': 'Ph∆∞∆°ng ph√°p lai (k·∫øt h·ª£p nhi·ªÅu y·∫øu t·ªë)'
    }
    
    # Th·ªùi gian key m·∫∑c ƒë·ªãnh
    KEY_DURATIONS = {
        '1': {'days': 1, 'hours': 0, 'label': '1 ng√†y'},
        '3': {'days': 3, 'hours': 0, 'label': '3 ng√†y'},
        '7': {'days': 7, 'hours': 0, 'label': '1 tu·∫ßn'},
        '30': {'days': 30, 'hours': 0, 'label': '1 th√°ng'},
        'custom': {'days': 0, 'hours': 0, 'label': 'T√πy ch·ªânh'}
    }

# --------------------- Thi·∫øt l·∫≠p logging ---------------------
def setup_logging():
    logger = logging.getLogger()
    logger.setLevel(Config.LOG_LEVEL)
    
    # File handler
    file_handler = logging.FileHandler(Config.LOG_FILE)
    file_handler.setFormatter(logging.Formatter(Config.LOG_FORMAT))
    logger.addHandler(file_handler)
    
    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(logging.Formatter(Config.LOG_FORMAT))
    logger.addHandler(console_handler)
    
    return logger

logger = setup_logging()

# --------------------- Database Helpers ---------------------
class Database:
    def __init__(self):
        self.conn = sqlite3.connect(Config.DB_FILE, check_same_thread=False)
        self.cursor = self.conn.cursor()
        self._create_tables()
    
    def _create_tables(self):
        """T·∫°o c√°c b·∫£ng database n·∫øu ch∆∞a t·ªìn t·∫°i"""
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            join_date TEXT,
            active_key TEXT,
            expiry_date TEXT,
            algorithm TEXT DEFAULT 'simple',
            request_count INTEGER DEFAULT 0,
            last_request_date TEXT
        )
        ''')
        
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS license_keys (
            key TEXT PRIMARY KEY,
            duration_days INTEGER,
            duration_hours INTEGER,
            created_date TEXT,
            created_by TEXT,
            used_by INTEGER,
            used_date TEXT,
            is_active INTEGER DEFAULT 1,
            note TEXT
        )
        ''')
        
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS request_logs (
            log_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            md5_hash TEXT,
            prediction TEXT,
            algorithm TEXT,
            timestamp TEXT,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )
        ''')
        
        self.conn.commit()
    
    def log_request(self, user_id: int, md5_hash: str, prediction: str, algorithm: str):
        """Ghi log y√™u c·∫ßu ph√¢n t√≠ch"""
        self.cursor.execute('''
        INSERT INTO request_logs (user_id, md5_hash, prediction, algorithm, timestamp)
        VALUES (?, ?, ?, ?, ?)
        ''', (user_id, md5_hash, prediction, algorithm, datetime.now().isoformat()))
        
        self.cursor.execute('''
        UPDATE users SET request_count = request_count + 1, last_request_date = ?
        WHERE user_id = ?
        ''', (datetime.now().isoformat(), user_id))
        
        self.conn.commit()

db = Database()

# --------------------- Thu·∫≠t to√°n ph√¢n t√≠ch MD5 ---------------------
class MD5Analyzer:
    @staticmethod
    def simple_analysis(md5_hash: str) -> str:
        """Ph√¢n t√≠ch ƒë∆°n gi·∫£n d·ª±a tr√™n k√Ω t·ª± cu·ªëi"""
        if len(md5_hash) != 32:
            raise ValueError("MD5 hash ph·∫£i c√≥ 32 k√Ω t·ª±")
        
        last_char = md5_hash[-1].lower()
        return "T√ÄI" if int(last_char, 16) >= 8 else "X·ªàU"
    
    @staticmethod
    def advanced_analysis(md5_hash: str) -> str:
        """Ph√¢n t√≠ch n√¢ng cao d·ª±a tr√™n nhi·ªÅu y·∫øu t·ªë"""
        if len(md5_hash) != 32:
            raise ValueError("MD5 hash ph·∫£i c√≥ 32 k√Ω t·ª±")
        
        # Ph√¢n t√≠ch c√°c ph·∫ßn c·ªßa hash
        parts = [md5_hash[i:i+8] for i in range(0, 32, 8)]
        sum_values = [sum(int(c, 16) for c in parts]
        avg_values = [s / 8 for s in sum_values]
        
        # ƒê·∫øm s·ªë ch·∫µn/l·∫ª
        even_count = sum(1 for c in md5_hash if int(c, 16) % 2 == 0)
        odd_count = 32 - even_count
        
        # Ph√¢n t√≠ch c·ª•m
        cluster_score = 0
        for i in range(len(md5_hash)-1):
            if abs(int(md5_hash[i], 16) - int(md5_hash[i+1], 16)) <= 2:
                cluster_score += 1
        
        # T√≠nh ƒëi·ªÉm
        tai_score = 0
        xiu_score = 0
        
        # ƒêi·ªÉm t·ª´ gi√° tr·ªã trung b√¨nh
        for avg in avg_values:
            if avg > 7.5:
                tai_score += 1
            else:
                xiu_score += 1
        
        # ƒêi·ªÉm t·ª´ ch·∫µn/l·∫ª
        if even_count > odd_count:
            tai_score += 1.5
        else:
            xiu_score += 1.5
        
        # ƒêi·ªÉm t·ª´ c·ª•m
        if cluster_score > 16:
            xiu_score += 1
        else:
            tai_score += 0.5
        
        return "T√ÄI" if tai_score > xiu_score else "X·ªàU"
    
    @staticmethod
    def statistical_analysis(md5_hash: str) -> str:
        """Ph√¢n t√≠ch th·ªëng k√™ d·ª±a tr√™n xu h∆∞·ªõng"""
        if len(md5_hash) != 32:
            raise ValueError("MD5 hash ph·∫£i c√≥ 32 k√Ω t·ª±")
        
        # Chuy·ªÉn sang gi√° tr·ªã s·ªë
        values = [int(c, 16) for c in md5_hash]
        
        # T√≠nh trung b√¨nh
        mean = sum(values) / len(values)
        
        # T√≠nh ƒë·ªô l·ªách
        deviation = sum((x - mean) ** 2 for x in values) / len(values)
        
        # Ph√¢n t√≠ch xu h∆∞·ªõng
        if mean > 7.5 and deviation > 8:
            return "T√ÄI"
        elif mean < 7.5 and deviation > 8:
            return "X·ªàU"
        else:
            # N·∫øu kh√¥ng r√µ r√†ng, d√πng ph∆∞∆°ng ph√°p ƒë∆°n gi·∫£n
            return MD5Analyzer.simple_analysis(md5_hash)
    
    @staticmethod
    def hybrid_analysis(md5_hash: str) -> str:
        """Ph∆∞∆°ng ph√°p lai k·∫øt h·ª£p nhi·ªÅu thu·∫≠t to√°n"""
        results = {
            'simple': MD5Analyzer.simple_analysis(md5_hash),
            'advanced': MD5Analyzer.advanced_analysis(md5_hash),
            'statistical': MD5Analyzer.statistical_analysis(md5_hash)
        }
        
        # ƒê·∫øm k·∫øt qu·∫£
        counts = {'T√ÄI': 0, 'X·ªàU': 0}
        for result in results.values():
            counts[result] += 1
        
        # Quy·∫øt ƒë·ªãnh d·ª±a tr√™n ƒëa s·ªë
        if counts['T√ÄI'] > counts['X·ªàU']:
            return "T√ÄI"
        elif counts['X·ªàU'] > counts['T√ÄI']:
            return "X·ªàU"
        else:
            # N·∫øu h√≤a, d√πng ph∆∞∆°ng ph√°p n√¢ng cao
            return results['advanced']

# --------------------- Telegram Bot Handlers ---------------------
def start(update: Update, context: CallbackContext) -> None:
    user = update.effective_user
    logger.info(f"User {user.id} started the bot")
    
    # Ki·ªÉm tra v√† th√™m user v√†o database n·∫øu ch∆∞a c√≥
    db.cursor.execute('SELECT * FROM users WHERE user_id = ?', (user.id,))
    if not db.cursor.fetchone():
        db.cursor.execute('''
        INSERT INTO users (user_id, username, join_date) 
        VALUES (?, ?, ?)
        ''', (user.id, user.username, datetime.now().isoformat()))
        db.conn.commit()
        logger.info(f"Added new user: {user.id}")
    
    # Ki·ªÉm tra key active
    db.cursor.execute('SELECT active_key, expiry_date FROM users WHERE user_id = ?', (user.id,))
    user_data = db.cursor.fetchone()
    
    if user_data and user_data[0] and datetime.fromisoformat(user_data[1]) > datetime.now():
        # User c√≥ key active
        keyboard = [
            [InlineKeyboardButton("üîç Ph√¢n t√≠ch MD5", callback_data='analyze_md5')],
            [InlineKeyboardButton("‚ÑπÔ∏è Th√¥ng tin key", callback_data='key_info')],
            [InlineKeyboardButton("‚öôÔ∏è C√†i ƒë·∫∑t thu·∫≠t to√°n", callback_data='algorithm_settings')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            'üé≤ Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi bot ph√¢n t√≠ch T√†i X·ªâu!\n'
            'üîë B·∫°n ƒëang c√≥ key active. Vui l√≤ng ch·ªçn ch·ª©c nƒÉng:',
            reply_markup=reply_markup
        )
    else:
        # User kh√¥ng c√≥ key ho·∫∑c key h·∫øt h·∫°n
        keyboard = [
            [InlineKeyboardButton("üîë Nh·∫≠p key", callback_data='enter_key')],
            [InlineKeyboardButton("üí≥ Mua key", url='https://example.com')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        update.message.reply_text(
            'üé≤ Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi bot ph√¢n t√≠ch T√†i X·ªâu!\n'
            'üîê B·∫°n c·∫ßn c√≥ key ƒë·ªÉ s·ª≠ d·ª•ng d·ªãch v·ª•. Vui l√≤ng ch·ªçn:',
            reply_markup=reply_markup
        )

def button_handler(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    query.answer()
    user_id = update.effective_user.id
    logger.info(f"Button pressed by {user_id}: {query.data}")
    
    if query.data == 'analyze_md5':
        query.edit_message_text(text="üî¢ Vui l√≤ng nh·∫≠p m√£ MD5 ƒë·ªÉ ph√¢n t√≠ch:")
        context.user_data['waiting_for_md5'] = True
    elif query.data == 'key_info':
        show_key_info(update, context)
    elif query.data == 'enter_key':
        query.edit_message_text(text="üîë Vui l√≤ng nh·∫≠p key c·ªßa b·∫°n:")
        context.user_data['waiting_for_key'] = True
    elif query.data == 'algorithm_settings':
        show_algorithm_settings(update, context)
    elif query.data.startswith('set_algorithm_'):
        algorithm = query.data.split('_')[-1]
        set_algorithm(update, context, algorithm)
    elif query.data == 'admin_panel' and user_id in Config.ADMIN_IDS:
        show_admin_panel(update, context)
    elif query.data.startswith('admin_create_key_'):
        duration = query.data.split('_')[-1]
        create_key(update, context, duration)
    elif query.data == 'admin_manage_keys':
        show_key_management(update, context)
    elif query.data == 'admin_user_stats':
        show_user_stats(update, context)
    elif query.data == 'back_to_menu':
        start_from_button(update, context)

def start_from_button(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    user = update.effective_user
    
    db.cursor.execute('SELECT active_key, expiry_date FROM users WHERE user_id = ?', (user.id,))
    user_data = db.cursor.fetchone()
    
    if user_data and user_data[0] and datetime.fromisoformat(user_data[1]) > datetime.now():
        keyboard = [
            [InlineKeyboardButton("üîç Ph√¢n t√≠ch MD5", callback_data='analyze_md5')],
            [InlineKeyboardButton("‚ÑπÔ∏è Th√¥ng tin key", callback_data='key_info')],
            [InlineKeyboardButton("‚öôÔ∏è C√†i ƒë·∫∑t thu·∫≠t to√°n", callback_data='algorithm_settings')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        query.edit_message_text(
            text='üé≤ Menu ch√≠nh - Ch·ªçn ch·ª©c nƒÉng:',
            reply_markup=reply_markup
        )
    else:
        keyboard = [
            [InlineKeyboardButton("üîë Nh·∫≠p key", callback_data='enter_key')],
            [InlineKeyboardButton("üí≥ Mua key", url='https://example.com')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        query.edit_message_text(
            text='üé≤ Menu ch√≠nh - B·∫°n c·∫ßn c√≥ key ƒë·ªÉ s·ª≠ d·ª•ng d·ªãch v·ª•:',
            reply_markup=reply_markup
        )

# --------------------- Ch·ª©c nƒÉng ph√¢n t√≠ch MD5 ---------------------
def analyze_md5(update: Update, context: CallbackContext) -> None:
    user = update.effective_user
    md5_input = update.message.text.strip().lower()
    logger.info(f"User {user.id} requested analysis for MD5: {md5_input}")
    
    # Ki·ªÉm tra key active
    db.cursor.execute('SELECT active_key, expiry_date, algorithm FROM users WHERE user_id = ?', (user.id,))
    user_data = db.cursor.fetchone()
    
    if not user_data or not user_data[0] or datetime.fromisoformat(user_data[1]) <= datetime.now():
        update.message.reply_text("‚ö†Ô∏è B·∫°n c·∫ßn c√≥ key active ƒë·ªÉ s·ª≠ d·ª•ng ch·ª©c nƒÉng n√†y.")
        return
    
    # Validate MD5
    if len(md5_input) != 32 or not all(c in '0123456789abcdef' for c in md5_input):
        update.message.reply_text("‚ùå M√£ MD5 kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i.")
        return
    
    # L·∫•y thu·∫≠t to√°n ƒë√£ ch·ªçn
    algorithm = user_data[2] or 'simple'
    
    # Ph√¢n t√≠ch theo thu·∫≠t to√°n
    try:
        if algorithm == 'simple':
            prediction = MD5Analyzer.simple_analysis(md5_input)
        elif algorithm == 'advanced':
            prediction = MD5Analyzer.advanced_analysis(md5_input)
        elif algorithm == 'statistical':
            prediction = MD5Analyzer.statistical_analysis(md5_input)
        elif algorithm == 'hybrid':
            prediction = MD5Analyzer.hybrid_analysis(md5_input)
        else:
            prediction = MD5Analyzer.simple_analysis(md5_input)
        
        # Ghi log
        db.log_request(user.id, md5_input, prediction, algorithm)
        
        # G·ª≠i k·∫øt qu·∫£
        update.message.reply_text(
            f"üéØ K·∫øt qu·∫£ ph√¢n t√≠ch:\n"
            f"üî¢ MD5: <code>{md5_input}</code>\n"
            f"üìä Thu·∫≠t to√°n: {Config.ALGORITHMS.get(algorithm, 'ƒê∆°n gi·∫£n')}\n"
            f"üîÆ D·ª± ƒëo√°n: <b>{prediction}</b>\n\n"
            f"üìå L∆∞u √Ω: ƒê√¢y ch·ªâ l√† d·ª± ƒëo√°n, kh√¥ng ƒë·∫£m b·∫£o 100% ch√≠nh x√°c",
            parse_mode='HTML'
        )
        
    except Exception as e:
        logger.error(f"Error analyzing MD5: {str(e)}")
        update.message.reply_text("‚ùå C√≥ l·ªói x·∫£y ra khi ph√¢n t√≠ch. Vui l√≤ng th·ª≠ l·∫°i.")

# --------------------- H·ªá th·ªëng key ---------------------
def handle_key_input(update: Update, context: CallbackContext) -> None:
    user = update.effective_user
    key_input = update.message.text.strip()
    logger.info(f"User {user.id} attempting to activate key: {key_input}")
    
    # Ki·ªÉm tra key trong database
    db.cursor.execute('SELECT * FROM license_keys WHERE key = ? AND is_active = 1', (key_input,))
    key_data = db.cursor.fetchone()
    
    if not key_data:
        update.message.reply_text("‚ùå Key kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng.")
        return
    
    # Ki·ªÉm tra key ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng ch∆∞a
    if key_data[5]:  # used_by
        update.message.reply_text("‚ùå Key n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ng∆∞·ªùi kh√°c.")
        return
    
    # T√≠nh to√°n ng√†y h·∫øt h·∫°n
    duration_days = key_data[1] or 0
    duration_hours = key_data[2] or 0
    expiry_date = datetime.now() + timedelta(days=duration_days, hours=duration_hours)
    
    # C·∫≠p nh·∫≠t database
    try:
        db.cursor.execute('''
        UPDATE license_keys SET used_by = ?, used_date = ? WHERE key = ?
        ''', (user.id, datetime.now().isoformat(), key_input))
        
        db.cursor.execute('''
        UPDATE users SET active_key = ?, expiry_date = ? WHERE user_id = ?
        ''', (key_input, expiry_date.isoformat(), user.id))
        
        db.conn.commit()
        
        update.message.reply_text(
            f"‚úÖ K√≠ch ho·∫°t key th√†nh c√¥ng!\n"
            f"üîë Key: <code>{key_input}</code>\n"
            f"‚è≥ H·∫øt h·∫°n v√†o: <b>{expiry_date.strftime('%Y-%m-%d %H:%M:%S')}</b>\n\n"
            f"üé≤ B√¢y gi·ªù b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng bot ƒë·ªÉ ph√¢n t√≠ch MD5!",
            parse_mode='HTML'
        )
        logger.info(f"Key {key_input} activated for user {user.id}")
        
    except Exception as e:
        db.conn.rollback()
        logger.error(f"Error activating key: {str(e)}")
        update.message.reply_text("‚ùå C√≥ l·ªói x·∫£y ra khi k√≠ch ho·∫°t key. Vui l√≤ng th·ª≠ l·∫°i.")

def show_key_info(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    user = update.effective_user
    
    db.cursor.execute('''
    SELECT u.active_key, u.expiry_date, k.duration_days, k.duration_hours, k.created_date
    FROM users u
    LEFT JOIN license_keys k ON u.active_key = k.key
    WHERE u.user_id = ?
    ''', (user.id,))
    
    key_info = db.cursor.fetchone()
    
    if key_info and key_info[0]:
        expiry_date = datetime.fromisoformat(key_info[1])
        remaining = expiry_date - datetime.now()
        remaining_str = f"{remaining.days} ng√†y, {remaining.seconds//3600} gi·ªù"
        
        message = (
            f"üîë Th√¥ng tin key c·ªßa b·∫°n:\n\n"
            f"üè∑Ô∏è Key: <code>{key_info[0]}</code>\n"
            f"‚è≥ H·∫øt h·∫°n: {expiry_date.strftime('%Y-%m-%d %H:%M:%S')}\n"
            f"üïí C√≤n l·∫°i: {remaining_str}\n"
            f"üìÖ Th·ªùi h·∫°n: {key_info[2]} ng√†y, {key_info[3]} gi·ªù\n"
            f"üìå T·∫°o ng√†y: {datetime.fromisoformat(key_info[4]).strftime('%Y-%m-%d') if key_info[4] else 'N/A'}"
        )
    else:
        message = "‚ùå B·∫°n ch∆∞a c√≥ key active. Vui l√≤ng nh·∫≠p key ƒë·ªÉ s·ª≠ d·ª•ng d·ªãch v·ª•."
    
    keyboard = [[InlineKeyboardButton("üîô Quay l·∫°i", callback_data='back_to_menu')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text=message,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )

# --------------------- C√†i ƒë·∫∑t thu·∫≠t to√°n ---------------------
def show_algorithm_settings(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    user = update.effective_user
    
    db.cursor.execute('SELECT algorithm FROM users WHERE user_id = ?', (user.id,))
    current_algorithm = db.cursor.fetchone()[0] or 'simple'
    
    keyboard = []
    for algo_key, algo_name in Config.ALGORITHMS.items():
        prefix = "‚úÖ " if algo_key == current_algorithm else "‚óªÔ∏è "
        keyboard.append([InlineKeyboardButton(
            f"{prefix}{algo_name}", 
            callback_data=f'set_algorithm_{algo_key}'
        )])
    
    keyboard.append([InlineKeyboardButton("üîô Quay l·∫°i", callback_data='back_to_menu')])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text="‚öôÔ∏è Ch·ªçn thu·∫≠t to√°n ph√¢n t√≠ch MD5:",
        reply_markup=reply_markup
    )

def set_algorithm(update: Update, context: CallbackContext, algorithm: str) -> None:
    query = update.callback_query
    user = update.effective_user
    
    if algorithm not in Config.ALGORITHMS:
        query.answer("‚ùå Thu·∫≠t to√°n kh√¥ng h·ª£p l·ªá", show_alert=True)
        return
    
    db.cursor.execute('''
    UPDATE users SET algorithm = ? WHERE user_id = ?
    ''', (algorithm, user.id))
    db.conn.commit()
    
    query.answer(f"‚úÖ ƒê√£ ƒë·∫∑t thu·∫≠t to√°n: {Config.ALGORITHMS[algorithm]}", show_alert=True)
    show_algorithm_settings(update, context)

# --------------------- Admin Functions ---------------------
def show_admin_panel(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    
    keyboard = [
        [InlineKeyboardButton("üîë T·∫°o key", callback_data='admin_create_key_menu')],
        [InlineKeyboardButton("üìä Qu·∫£n l√Ω key", callback_data='admin_manage_keys')],
        [InlineKeyboardButton("üë• Th·ªëng k√™ user", callback_data='admin_user_stats')],
        [InlineKeyboardButton("üìù Xem logs", callback_data='admin_view_logs')],
        [InlineKeyboardButton("üîô Menu ch√≠nh", callback_data='back_to_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text="üëë Admin Panel - Ch·ªçn ch·ª©c nƒÉng:",
        reply_markup=reply_markup
    )

def show_key_creation_menu(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    
    keyboard = []
    for key, value in Config.KEY_DURATIONS.items():
        if key != 'custom':
            keyboard.append([InlineKeyboardButton(
                f"‚è≥ T·∫°o key {value['label']}", 
                callback_data=f'admin_create_key_{key}'
            )])
    
    keyboard.append([InlineKeyboardButton("üõ†Ô∏è T·∫°o key t√πy ch·ªânh", callback_data='admin_create_key_custom')])
    keyboard.append([InlineKeyboardButton("üîô Quay l·∫°i", callback_data='admin_panel')])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text="üîë Ch·ªçn lo·∫°i key c·∫ßn t·∫°o:",
        reply_markup=reply_markup
    )

def create_key(update: Update, context: CallbackContext, duration: str) -> None:
    query = update.callback_query
    admin_id = update.effective_user.id
    
    if duration == 'custom':
        query.edit_message_text(text="üõ†Ô∏è Vui l√≤ng nh·∫≠p th·ªùi h·∫°n key (ƒë·ªãnh d·∫°ng: <ng√†y> <gi·ªù>, v√≠ d·ª•: 3 12 cho 3 ng√†y 12 gi·ªù):")
        context.user_data['waiting_for_custom_key_duration'] = True
        return
    
    duration_config = Config.KEY_DURATIONS.get(duration, Config.KEY_DURATIONS['1'])
    days = duration_config['days']
    hours = duration_config['hours']
    
    # T·∫°o key ng·∫´u nhi√™n
    new_key = secrets.token_hex(8)  # 16 k√Ω t·ª± hex
    
    # L∆∞u v√†o database
    db.cursor.execute('''
    INSERT INTO license_keys (key, duration_days, duration_hours, created_date, created_by, is_active)
    VALUES (?, ?, ?, ?, ?, ?)
    ''', (new_key, days, hours, datetime.now().isoformat(), admin_id, 1))
    db.conn.commit()
    
    query.answer(f"‚úÖ ƒê√£ t·∫°o key {days} ng√†y {hours} gi·ªù: {new_key}", show_alert=True)
    logger.info(f"Admin {admin_id} created new key: {new_key} ({days} days, {hours} hours)")

def handle_custom_key_duration(update: Update, context: CallbackContext) -> None:
    admin_id = update.effective_user.id
    text = update.message.text.strip()
    logger.info(f"Admin {admin_id} creating custom key with duration: {text}")
    
    try:
        parts = text.split()
        days = int(parts[0]) if len(parts) > 0 else 0
        hours = int(parts[1]) if len(parts) > 1 else 0
        
        if days < 0 or hours < 0:
            raise ValueError("Th·ªùi gian kh√¥ng h·ª£p l·ªá")
        
        # T·∫°o key ng·∫´u nhi√™n
        new_key = secrets.token_hex(8)
        
        # L∆∞u v√†o database
        db.cursor.execute('''
        INSERT INTO license_keys (key, duration_days, duration_hours, created_date, created_by, is_active)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (new_key, days, hours, datetime.now().isoformat(), admin_id, 1))
        db.conn.commit()
        
        update.message.reply_text(
            f"‚úÖ ƒê√£ t·∫°o key t√πy ch·ªânh th√†nh c√¥ng!\n"
            f"üîë Key: <code>{new_key}</code>\n"
            f"‚è≥ Th·ªùi h·∫°n: {days} ng√†y {hours} gi·ªù\n\n"
            f"üìå G·ª≠i key n√†y cho ng∆∞·ªùi d√πng ƒë·ªÉ h·ªç k√≠ch ho·∫°t.",
            parse_mode='HTML'
        )
        logger.info(f"Admin {admin_id} created custom key: {new_key} ({days}d {hours}h)")
        
    except Exception as e:
        logger.error(f"Error creating custom key: {str(e)}")
        update.message.reply_text("‚ùå ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i (v√≠ d·ª•: '3 12' cho 3 ng√†y 12 gi·ªù).")

def show_key_management(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    
    # L·∫•y danh s√°ch key
    db.cursor.execute('''
    SELECT key, duration_days, duration_hours, created_date, used_by, is_active
    FROM license_keys
    ORDER BY created_date DESC
    LIMIT 50
    ''')
    keys = db.cursor.fetchall()
    
    if not keys:
        query.edit_message_text(text="üì≠ Kh√¥ng c√≥ key n√†o trong database.")
        return
    
    message = "üîë Danh s√°ch key (50 m·ªõi nh·∫•t):\n\n"
    for key in keys:
        status = "‚úÖ Active" if key[5] else "‚ùå Inactive"
        used = "üü¢ Ch∆∞a d√πng" if not key[4] else f"üî¥ ƒê√£ d√πng b·ªüi {key[4]}"
        message += (
            f"üè∑Ô∏è <code>{key[0]}</code>\n"
            f"‚è≥ {key[1]}d {key[2]}h | üìÖ {datetime.fromisoformat(key[3]).strftime('%Y-%m-%d')}\n"
            f"{status} | {used}\n\n"
        )
    
    keyboard = [[InlineKeyboardButton("üîô Quay l·∫°i", callback_data='admin_panel')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text=message,
        reply_markup=reply_markup,
        parse_mode='HTML'
    )

def show_user_stats(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    
    # Th·ªëng k√™ user
    db.cursor.execute('SELECT COUNT(*) FROM users')
    total_users = db.cursor.fetchone()[0]
    
    db.cursor.execute('''
    SELECT COUNT(*) FROM users 
    WHERE active_key IS NOT NULL AND expiry_date > ?
    ''', (datetime.now().isoformat(),))
    active_users = db.cursor.fetchone()[0]
    
    db.cursor.execute('''
    SELECT username, request_count, last_request_date 
    FROM users 
    WHERE request_count > 0
    ORDER BY request_count DESC
    LIMIT 10
    ''')
    top_users = db.cursor.fetchall()
    
    message = (
        f"üë• Th·ªëng k√™ ng∆∞·ªùi d√πng:\n\n"
        f"üìä T·ªïng user: {total_users}\n"
        f"üü¢ User active: {active_users}\n\n"
        f"üèÜ Top 10 user t√≠ch c·ª±c:\n"
    )
    
    for i, user in enumerate(top_users, 1):
        last_active = datetime.fromisoformat(user[2]).strftime('%Y-%m-%d') if user[2] else "N/A"
        message += f"{i}. {user[0] or 'N/A'}: {user[1]} l·∫ßn (cu·ªëi: {last_active})\n"
    
    keyboard = [[InlineKeyboardButton("üîô Quay l·∫°i", callback_data='admin_panel')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    query.edit_message_text(
        text=message,
        reply_markup=reply_markup
    )

# --------------------- Main Handler ---------------------
def handle_message(update: Update, context: CallbackContext) -> None:
    if context.user_data.get('waiting_for_md5'):
        context.user_data.pop('waiting_for_md5', None)
        analyze_md5(update, context)
    elif context.user_data.get('waiting_for_key'):
        context.user_data.pop('waiting_for_key', None)
        handle_key_input(update, context)
    elif context.user_data.get('waiting_for_custom_key_duration'):
        context.user_data.pop('waiting_for_custom_key_duration', None)
        handle_custom_key_duration(update, context)
    else:
        update.message.reply_text("‚ÑπÔ∏è Vui l√≤ng s·ª≠ d·ª•ng c√°c n√∫t ch·ª©c nƒÉng ho·∫∑c g√µ /start ƒë·ªÉ b·∫Øt ƒë·∫ßu.")

def error_handler(update: Update, context: CallbackContext) -> None:
    logger.error(msg="Exception while handling update:", exc_info=context.error)
    
    if update and update.effective_message:
        update.effective_message.reply_text(
            "‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c li√™n h·ªá admin."
        )

# --------------------- Kh·ªüi ch·∫°y bot ---------------------
def main() -> None:
    # T·∫°o updater v√† dispatcher
    updater = Updater("7749085860:AAE0Hdk-D3OIGb3KjfT9fu5N6Lr7xvAqny8", use_context=True)
    dispatcher = updater.dispatcher

    # Th√™m c√°c handler
    dispatcher.add_handler(CommandHandler("start", start))
    dispatcher.add_handler(CallbackQueryHandler(button_handler))
    dispatcher.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    dispatcher.add_error_handler(error_handler)
    
    # Kh·ªüi ch·∫°y bot
    logger.info("Bot is starting...")
    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()
